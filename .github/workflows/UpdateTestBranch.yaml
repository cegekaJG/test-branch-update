name: Update Test Branch

on:
  issue_comment:
    types:
      created

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  TEST_BRANCH: test/main
  FEATURE_TEST_PREFIX: test/
  NOTICE_COMMENT_TAG: <!-- UpdateTestBranch/NOTICE -->
  BOT_LABEL: Automated
  DISABLE_COMMENTS: false
  AUTOMERGE: true

jobs:
  setup:
    name: Initialize Update
    runs-on: ubuntu-latest
    if: github.event.issue.pull_request && startsWith(github.event.comment.body, '!update-test')
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    outputs:
      test_branch: ${{ steps.set_config.outputs.TEST_BRANCH }}
      feature_branch: ${{ steps.get_pr_info.outputs.HEAD_REF }}
      base_branch: ${{ steps.get_pr_info.outputs.BASE_REF }}
      feature_test_prefix: ${{ steps.set_config.outputs.FEATURE_TEST_PREFIX }}
      bot_label: ${{ steps.set_config.outputs.BOT_LABEL }}
      disable_comments: ${{ steps.set_config.outputs.DISABLE_COMMENTS }}
      pr_exists: ${{ steps.check_pr.outputs.PR_EXISTS }}
      RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      AUTOMERGE: ${{ steps.set_config.outputs.AUTOMERGE }}
      progress_comment_id: ${{ steps.create_progress_comment.outputs.comment-id }}
      GH_TOKEN: ${{ env.GH_TOKEN }}
    steps:
      - name: 'Setup jq'
        uses: dcarbone/install-jq-action@v3

      - name: Setup GH_TOKEN
        env:
          CUSTOM_TOKEN: ${{ secrets.UPDATETESTTOKEN }}
        run: |
          if [ -z "$CUSTOM_TOKEN" ]; then
            echo "::error::The UPDATETESTTOKEN secret is required."
            cat << 'EOF' >> $STEP_SUMMARY
          ## ‚ö†Ô∏è UPDATETESTTOKEN Secret Not Found

          The UPDATETESTTOKEN secret is required to automatically trigger pull request workflows.
          For information on how to add the repository secret, see: https://github.com/microsoft/AL-Go/blob/main/Scenarios/UpdateTestToken.md
          EOF
            exit 1
          else
            # Make the get-gh-token script executable
            chmod +x .github/scripts/get-gh-token.sh
            # Use the get-gh-token script to handle both PAT and GitHub App credentials
            GH_TOKEN_VALUE=$(.github/scripts/get-gh-token.sh "$CUSTOM_TOKEN")
            echo "GH_TOKEN=$GH_TOKEN_VALUE" >> $GITHUB_ENV
          fi

      - name: Create progress comment
        id: create_progress_comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ env.GH_TOKEN }}
          issue-number: ${{ github.event.issue.number }}
          body: |
            üöÄ Update test branch workflow started.

            [View workflow run](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})

      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Get PR information
        id: get_pr_info
        run: |
          pr_info=$(gh pr view ${{ github.event.issue.number }} --json headRefName,baseRefName,title)

          printf "::debug::PR info: %q\n" "$pr_info"

          if [ -z "$pr_info" ]; then
            echo "::error::Failed to get PR information. Please try again."
            exit 1
          fi

          head_ref=$(echo "$pr_info" | jq -r '.headRefName')
          base_ref=$(echo "$pr_info" | jq -r '.baseRefName')
          pr_title=$(echo "$pr_info" | jq -r '.title')

          echo "Head ref: $head_ref"
          echo "Base ref: $base_ref"
          echo "PR title: $pr_title"

          echo "HEAD_REF=$head_ref" >> $GITHUB_OUTPUT
          echo "BASE_REF=$base_ref" >> $GITHUB_OUTPUT
          echo "PR_TITLE=$pr_title" >> $GITHUB_OUTPUT

      - name: Set configuration variables
        id: set_config
        env:
          UPDATETESTBRANCH_TEST_BRANCH: ${{ vars.UPDATETESTBRANCH_TEST_BRANCH || env.TEST_BRANCH }}
          UPDATETESTBRANCH_FEATURE_TEST_PREFIX: ${{ vars.UPDATETESTBRANCH_FEATURE_TEST_PREFIX || env.FEATURE_TEST_PREFIX }}
          UPDATETESTBRANCH_BOT_LABEL: ${{ vars.UPDATETESTBRANCH_BOT_LABEL || env.BOT_LABEL }}
          UPDATETESTBRANCH_DISABLE_COMMENTS: ${{ vars.UPDATETESTBRANCH_DISABLE_COMMENTS || env.DISABLE_COMMENTS }}
          UPDATETESTBRANCH_AUTOMERGE: ${{ vars.UPDATETESTBRANCH_AUTOMERGE || env.AUTOMERGE }}
        run: |
          # Sanitize inputs to prevent code injection
          printf 'TEST_BRANCH=%s\n' "$UPDATETESTBRANCH_TEST_BRANCH" >> $GITHUB_OUTPUT
          printf 'FEATURE_TEST_PREFIX=%s\n' "$UPDATETESTBRANCH_FEATURE_TEST_PREFIX" >> $GITHUB_OUTPUT
          printf 'BOT_LABEL=%s\n' "$UPDATETESTBRANCH_BOT_LABEL" >> $GITHUB_OUTPUT
          printf 'DISABLE_COMMENTS=%s\n' "$UPDATETESTBRANCH_DISABLE_COMMENTS" >> $GITHUB_OUTPUT
          printf 'AUTOMERGE=%s\n' "$UPDATETESTBRANCH_AUTOMERGE" >> $GITHUB_OUTPUT

      - name: Look for existing update PR
        id: check_pr
        env:
          TEST_BRANCH: ${{ steps.set_config.outputs.TEST_BRANCH }}
          FEATURE_BRANCH: ${{ steps.get_pr_info.outputs.HEAD_REF }}
          FEATURE_TEST_PREFIX: ${{ steps.set_config.outputs.FEATURE_TEST_PREFIX }}
        run: |
          feature_test_branch="${FEATURE_TEST_PREFIX}${FEATURE_BRANCH}"

          if [ $(gh pr list --base "${TEST_BRANCH}" --head "${feature_test_branch}" --state open | wc -l) -gt 0 ]; then
            echo "PR already exists."
            echo "PR_EXISTS=true" >> $GITHUB_OUTPUT
          else
            echo "No PR of ${feature_test_branch} to ${TEST_BRANCH} found."
            echo "PR_EXISTS=false" >> $GITHUB_OUTPUT
          fi

      - name: Ensure bot label exists
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BOT_LABEL: ${{ steps.set_config.outputs.bot_label }}
        run: |
          if [ -z "$(gh label list --json "id,name" --jq '.[] | select(.name == "'"${BOT_LABEL}"'")')" ]; then
            if ! gh label create "${BOT_LABEL}" --color CCCCCC --description "Automated pull requests"; then
              echo "::error::Failed to create label ${BOT_LABEL}. No label will be applied to the test PR. You can create it manually by going to the Labels section of the repository settings."
              BOT_LABEL=""
            else
              echo "::notice::Label '${BOT_LABEL}' created"
            fi
          else
            echo "Label ${BOT_LABEL} already exists"
          fi

  call_core_workflow:
    name: Call Core Update Workflow
    needs: setup
    uses: ./.github/workflows/UpdateTestBranchCore.yaml
    with:
      test_branch: ${{ needs.setup.outputs.test_branch }}
      feature_branch: ${{ needs.setup.outputs.feature_branch }}
      base_branch: ${{ needs.setup.outputs.base_branch }}
      feature_test_prefix: ${{ needs.setup.outputs.feature_test_prefix }}

  update_progress_comment:
    name: Update Progress Comment
    needs: [setup, call_core_workflow]
    runs-on: ubuntu-latest
    if: always() && github.event.issue.pull_request && startsWith(github.event.comment.body, '!update-test')
    env:
      GH_TOKEN: ${{ needs.setup.outputs.GH_TOKEN || secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: 'Setup jq'
        uses: dcarbone/install-jq-action@v3

      - name: Update comment with outcome
        uses: peter-evans/create-or-update-comment@v4
        with:
          token: ${{ env.GH_TOKEN }}
          comment-id: ${{ needs.setup.outputs.progress_comment_id }}
          edit-mode: replace
          body: |
            ${{ needs.call_core_workflow.result != 'success' && '‚ùå Update test branch workflow encountered an error. Finishing workflow...' || needs.call_core_workflow.outputs.no_changes == 'true' && '‚úÖ No new changes found to cherry-pick. Finishing workflow...' || (needs.call_core_workflow.outputs.cherry_pick_success == 'true' && '‚úÖ Cherry-pick completed successfully! Finishing workflow...' || '‚ùå Cherry-pick failed due to conflicts. Finishing workflow...') }}

            [View workflow run](${{ needs.setup.outputs.RUN_URL }})

  update_prs:
    name: Update Pull Requests
    needs: [setup, call_core_workflow, update_progress_comment]
    runs-on: ubuntu-latest
    env:
      GH_TOKEN: ${{ needs.setup.outputs.GH_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: 'Setup jq'
        uses: dcarbone/install-jq-action@v3

      - name: Check if feature test branch exists
        id: check_branch
        env:
          FEATURE_TEST_BRANCH: ${{ needs.call_core_workflow.outputs.feature_test_branch }}
        run: |
          if git ls-remote --heads origin | grep -q "refs/heads/${FEATURE_TEST_BRANCH}$"; then
            echo "BRANCH_EXISTS=true" >> $GITHUB_OUTPUT
            echo "Feature test branch ${FEATURE_TEST_BRANCH} exists remotely."
          else
            echo "BRANCH_EXISTS=false" >> $GITHUB_OUTPUT
            echo "Feature test branch ${FEATURE_TEST_BRANCH} does not exist remotely."
          fi

      - name: Get feature PR URL
        id: get_feature_pr_url
        env:
          FALLBACK_URL: https://github.com/${{ github.repository }}/pull/${{ github.event.issue.number }}
        run: |
          pr_info=$(gh pr view ${{ github.event.issue.number }} --json url)

          printf "::debug::PR info: %q\n" "$pr_info"

          if [ -z "$pr_info" ]; then
            echo "::notice::Failed to get PR information. Using fallback URL."
            pr_url="$FALLBACK_URL"
          else
            pr_url=$(echo "$pr_info" | jq -r '.url')
          fi

          echo "PR URL: $pr_url"
          echo "FEATURE_PR_URL=$pr_url" >> $GITHUB_OUTPUT

      - name: Create/Update test pull request
        id: create_pr
        if: needs.setup.outputs.pr_exists == 'true' || needs.call_core_workflow.outputs.no_changes == 'false' || (needs.setup.outputs.pr_exists == 'false' && steps.check_branch.outputs.branch_exists == 'true')
        env:
          FEATURE_BRANCH: ${{ needs.setup.outputs.feature_branch }}
          BASE_BRANCH: ${{ needs.setup.outputs.base_branch }}
          TEST_BRANCH: ${{ needs.setup.outputs.test_branch }}
          BOT_LABEL: ${{ needs.setup.outputs.bot_label }}
          FEATURE_TEST_BRANCH: ${{ needs.call_core_workflow.outputs.feature_test_branch }}
          PR_EXISTS: ${{ needs.setup.outputs.pr_exists }}
          FEATURE_TITLE: ${{ github.event.issue.title }}
          FEATURE_PR_URL: ${{ steps.get_feature_pr_url.outputs.FEATURE_PR_URL }}
          ASSIGNEES_JSON: ${{ toJSON(github.event.issue.assignees) }}
        run: |
          feature_test_title="${FEATURE_TITLE} - Test"
          echo "PR title: ${feature_test_title}"
          body="This automated pull request adds the cherry-picked changes from \`${FEATURE_BRANCH}\` to \`${TEST_BRANCH}\`.
          See ${FEATURE_PR_URL} for more details."

          # Extract assignee logins from JSON array and format as comma-separated list
          ASSIGNEES=$(echo "${ASSIGNEES_JSON}" | jq -r 'if . == null or . == [] then "" else map(.login) | join(",") end')

          if [ "${PR_EXISTS}" == 'false' ]; then
            # Build assignee parameter if there are assignees
            ASSIGNEE_PARAM=""
            if [ -n "${ASSIGNEES}" ]; then
              ASSIGNEE_PARAM="--assignee ${ASSIGNEES}"
            fi

            TEST_PR_URL=$(gh pr create \
              --base "${TEST_BRANCH}" \
              --head "${FEATURE_TEST_BRANCH}" \
              --title "${feature_test_title}" \
              --label "${BOT_LABEL}" \
              --draft \
              ${ASSIGNEE_PARAM} \
              --body "${body}")
            echo "::notice::${TEST_PR_URL} created."
          else
            # Build assignee parameter if there are assignees
            ASSIGNEE_PARAM=""
            if [ -n "${ASSIGNEES}" ]; then
              ASSIGNEE_PARAM="--add-assignee ${ASSIGNEES}"
            fi

            TEST_PR_URL=$(gh pr edit "${FEATURE_TEST_BRANCH}" \
              --title "${feature_test_title}" \
              --body "${body}" \
              ${ASSIGNEE_PARAM})
            echo "::notice::${TEST_PR_URL} updated."
          fi

          pr_number=$(basename "${TEST_PR_URL}")

          echo "TEST_PR_EXISTS=true" >> $GITHUB_OUTPUT
          echo "TEST_PR_URL=${TEST_PR_URL}" >> $GITHUB_OUTPUT
          echo "TEST_PR_NUMBER=${pr_number}" >> $GITHUB_OUTPUT

      - name: Set pull request status
        if: steps.create_pr.outputs.test_pr_exists == 'true'
        env:
          TEST_PR_NUMBER: ${{ steps.create_pr.outputs.test_pr_number }}
          FEATURE_TEST_BRANCH: ${{ needs.call_core_workflow.outputs.feature_test_branch }}
          CHERRY_PICK_SUCCESS: ${{ needs.call_core_workflow.outputs.cherry_pick_success }}
          NO_CHANGES: ${{ needs.call_core_workflow.outputs.no_changes }}
        run: |
          if [ "${CHERRY_PICK_SUCCESS}" == "true" ]; then
            gh pr ready "${FEATURE_TEST_BRANCH}"
          else
            gh pr ready --undo "${FEATURE_TEST_BRANCH}"
          fi

      - name: Enable auto-merge on test PR
        if: steps.create_pr.outputs.test_pr_exists == 'true' && needs.call_core_workflow.outputs.cherry_pick_success == 'true' && needs.setup.outputs.automerge == 'true'
        env:
          TEST_PR_NUMBER: ${{ steps.create_pr.outputs.test_pr_number }}
        run: |
          # Enable auto-merge using gh CLI (requires repo admin permissions)
          gh pr merge "$TEST_PR_NUMBER" --auto --squash || echo "::notice::Auto-merge could not be enabled."

      - name: Clean up old comments
        uses: actions/github-script@v7
        continue-on-error: true
        env:
          TEST_PR_URL: ${{ steps.create_pr.outputs.test_pr_url }}
          NOTICE_COMMENT_TAG: ${{ env.NOTICE_COMMENT_TAG }}
        with:
          script: |
            (async () => {
              const TEST_PR_URL = process.env.TEST_PR_URL;
              const NOTICE_COMMENT_TAG = process.env.NOTICE_COMMENT_TAG;

              let newPrComments = [];
              if (TEST_PR_URL) {
                const urlSubstrings = TEST_PR_URL.split('/');
                const newPrNumber = urlSubstrings[urlSubstrings.length - 1];
                try {
                  newPrComments = await github.rest.issues.listComments({
                    issue_number: newPrNumber,
                    owner: context.repo.owner,
                    repo: context.repo.repo
                  });
                } catch (error) {
                  process.stdout.write(`::error::Error retrieving comments from new PR #${newPrNumber}: ${error.message}\n`);
                  newPrComments = [];
                }
              }
              let oldPrComments = [];
              try {
                oldPrComments = await github.rest.issues.listComments({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
              } catch (error) {
                process.stdout.write(`::error::Error retrieving comments from PR #${context.issue.number}: ${error.message}\n`);
                oldPrComments = [];
              }
              const allComments = [oldPrComments, newPrComments];
              for (const comments of allComments) {
                if (comments && Array.isArray(comments.data)) {
                  for (const comment of comments.data) {
                    if (comment.user.login === 'github-actions[bot]' && comment.body.startsWith(NOTICE_COMMENT_TAG)) {
                      try {
                        await github.rest.issues.deleteComment({
                          comment_id: comment.id,
                          owner: context.repo.owner,
                          repo: context.repo.repo
                        });
                        process.stdout.write(`Deleted comment ${comment.html_url}\n`);
                      } catch (error) {
                        process.stdout.write(`::notice::Error deleting comment ${comment.html_url}: ${error.message}\n`);
                      }
                    }
                  }
                } else {
                  process.stdout.write(`::debug::Comment data is not iterable.`)
                }
              }
            })();

      - name: Comment on test PR (on failure)
        if: needs.call_core_workflow.outputs.cherry_pick_success == 'false' && needs.setup.outputs.disable_comments == 'false'
        uses: peter-evans/create-or-update-comment@v4
        env:
          TEST_BRANCH: ${{ needs.setup.outputs.test_branch }}
          FEATURE_TEST_BRANCH: ${{ needs.call_core_workflow.outputs.feature_test_branch }}
          MISSING_COMMITS: ${{ needs.call_core_workflow.outputs.missing_commits }}
          NOTICE_COMMENT_TAG: ${{ env.NOTICE_COMMENT_TAG }}
        with:
          token: ${{ env.GH_TOKEN }}
          issue-number: ${{ steps.create_pr.outputs.test_pr_number }}
          body: |
            ${{ env.NOTICE_COMMENT_TAG }}
            **Automatic ${{ env.TEST_BRANCH }} update failed.**

            To manually resolve the merge conflicts, please follow these steps:

            1) Checkout the latest version of the branch `${{ env.FEATURE_TEST_BRANCH }}` with the following commands:
            ```bash
            git fetch origin ${{ env.FEATURE_TEST_BRANCH }}
            git checkout ${{ env.FEATURE_TEST_BRANCH }}
            git reset --hard origin/${{ env.FEATURE_TEST_BRANCH }}
            git cherry-pick -x ${{ env.MISSING_COMMITS }}
            ```
            2) Manually cherry-pick the failing commits and resolve any conflicts.
            3) Push the changes and set the PR to ready for review.

      - name: Update progress comment with final result
        if: needs.setup.outputs.disable_comments == 'false'
        uses: peter-evans/create-or-update-comment@v4
        env:
          FEATURE_BRANCH: ${{ needs.setup.outputs.feature_branch }}
          TEST_BRANCH: ${{ needs.setup.outputs.test_branch }}
          TEST_PR_URL: ${{ steps.create_pr.outputs.test_pr_url }}
          CHERRY_PICK_SUCCESS: ${{ needs.call_core_workflow.outputs.cherry_pick_success }}
          NO_CHANGES: ${{ needs.call_core_workflow.outputs.no_changes }}
          RUN_URL: ${{ needs.setup.outputs.RUN_URL }}
          TEST_PR_EXISTS: ${{ steps.create_pr.outputs.test_pr_exists }}
        with:
          token: ${{ env.GH_TOKEN }}
          comment-id: ${{ needs.setup.outputs.progress_comment_id }}
          edit-mode: replace
          body: |
            ${{ env.NO_CHANGES == 'true' && env.TEST_PR_EXISTS == 'true' && format('‚úÖ No new changes found to cherry-pick.

            No new changes were found in `{0}` to update the `{1}` branch.

            A pull request has been created or updated for the existing test branch. See {2} for more details.

            [View workflow run]({3})', env.FEATURE_BRANCH, env.TEST_BRANCH, env.TEST_PR_URL, env.RUN_URL) || env.NO_CHANGES == 'true' && format('‚úÖ No new changes found to cherry-pick.

            No new changes were found in `{0}` to update the `{1}` branch.

            [View workflow run]({2})', env.FEATURE_BRANCH, env.TEST_BRANCH, env.RUN_URL) || env.CHERRY_PICK_SUCCESS == 'true' && format('‚úÖ Cherry-pick completed successfully!

            The cherry-picked changes from `{0}` are ready to be added to the `{1}` branch.

            A new pull request has been created to test the changes. See {2} for more details.

            [View workflow run]({3})', env.FEATURE_BRANCH, env.TEST_BRANCH, env.TEST_PR_URL, env.RUN_URL) || format('‚ùå Cherry-pick failed due to conflicts.

            Unable to cherry-pick the changes from `{0}` to the `{1}` branch.

            A new pull request has been created to manually resolve the merge conflicts and test the changes. See {2} for more details.

            [View workflow run]({3})', env.FEATURE_BRANCH, env.TEST_BRANCH, env.TEST_PR_URL, env.RUN_URL) }}

  comment_error:
    name: Update Progress Comment on Error
    needs: [setup, call_core_workflow, update_prs]
    runs-on: ubuntu-latest
    if: failure() && needs.setup.outputs.disable_comments == 'false'
    env:
      GH_TOKEN: ${{ needs.setup.outputs.GH_TOKEN || secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Update progress comment with error
        uses: peter-evans/create-or-update-comment@v4
        env:
          RUN_URL: ${{ needs.setup.outputs.RUN_URL }}
        with:
          token: ${{ env.GH_TOKEN }}
          comment-id: ${{ needs.setup.outputs.progress_comment_id }}
          edit-mode: replace
          body: |
            ‚ùå An error occurred while updating the test branch.

            Please check the workflow run for details:
            [View workflow run](${{ env.RUN_URL }})
