name: Update Test Branch

on:
  issue_comment:
    types:
      created

permissions:
  contents: write
  pull-requests: write
  issues: write

env:
  TEST_BRANCH: test/main
  FEATURE_TEST_PREFIX: test/
  NOTICE_COMMENT_TAG: <!-- UpdateTestBranch/NOTICE -->
  BOT_LABEL: Automated
  DISABLE_COMMENTS: false
  AUTOMERGE: true

jobs:
  update_test_branch:
    name: Update Test Branch
    runs-on: ubuntu-latest
    if: github.event.issue.pull_request && startsWith(github.event.comment.body, '!update-test')
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      RUN_URL: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
      SKIP_ALL: false
      FEATURE_COMMITS: ''
      FEATURE_TEST_BRANCH: ''
      PICKED_COMMITS: ''
      ADDED_COMMITS: ''
      NO_CHANGES: true
      MISSING_COMMITS: ''
      CHERRY_PICK_FAILED: false
    outputs:
      progress_comment_id: ${{ steps.create_progress_comment.outputs.comment-id }}
      disable_comments: ${{ steps.set_config.outputs.DISABLE_COMMENTS }}
      RUN_URL: ${{ env.RUN_URL }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Create progress comment
        id: create_progress_comment
        uses: peter-evans/create-or-update-comment@v4
        with:
          issue-number: ${{ github.event.issue.number }}
          body: |
            üöÄ Update test branch workflow started.

            [View workflow run](${{ env.RUN_URL }})

      - name: 'Setup jq'
        uses: dcarbone/install-jq-action@v3

      - name: 'Set file permissions'
        run: |
          chmod +x .github/scripts/get-jwt.sh
          chmod +x .github/scripts/get-gh-token.sh

      - name: 'Check for GitHub App JWT'
        id: get_app_jwt
        env:
          CUSTOM_TOKEN: ${{ secrets.UPDATETESTTOKEN }}
        run: |
          if [ -z "$CUSTOM_TOKEN" ]; then
            echo "::error::The UPDATETESTTOKEN secret is required."
            cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## ‚ö†Ô∏è UPDATETESTTOKEN Secret Not Found

          The UPDATETESTTOKEN secret is required to automatically trigger pull request workflows.
          For information on how to add the repository secret, see: https://github.com/microsoft/AL-Go/blob/main/Scenarios/GhTokenWorkflow.md
          EOF
            exit 1
          else
            TOKEN_JWT_VALUE=$(.github/scripts/get-jwt.sh "$CUSTOM_TOKEN")
            echo "TOKEN_JWT=$TOKEN_JWT_VALUE" >> $GITHUB_OUTPUT
          fi

      - name: Setup GH_TOKEN
        env:
          TOKEN_JWT: ${{ steps.get_app_jwt.outputs.TOKEN_JWT }}
          CUSTOM_TOKEN: ${{ secrets.UPDATETESTTOKEN }}
        run: |
          if [ -n "$TOKEN_JWT" ]; then
            echo "Using GitHub App JWT for authentication"
            TOKEN_VALUE=$TOKEN_JWT
          else
            echo "Using Personal Access Token for authentication"
            TOKEN_VALUE=$CUSTOM_TOKEN
          fi
          GH_TOKEN_VALUE=$(.github/scripts/get-gh-token.sh "$TOKEN_VALUE")
          echo "GH_TOKEN=$GH_TOKEN_VALUE" >> $GITHUB_ENV

      - name: 'Revert changes from setting permissions'
        run: |
          git checkout -- .github/scripts/

      - name: Get PR information
        id: get_pr_info
        run: |
          pr_info=$(gh pr view ${{ github.event.issue.number }} --json headRefName,baseRefName,title)

          printf "::debug::PR info: %q\n" "$pr_info"

          if [ -z "$pr_info" ]; then
            echo "::error::Failed to get PR information. Please try again."
            exit 1
          fi

          head_ref=$(echo "$pr_info" | jq -r '.headRefName')
          base_ref=$(echo "$pr_info" | jq -r '.baseRefName')
          pr_title=$(echo "$pr_info" | jq -r '.title')

          echo "Head ref: $head_ref"
          echo "Base ref: $base_ref"
          echo "PR title: $pr_title"

          echo "HEAD_REF=$head_ref" >> $GITHUB_OUTPUT
          echo "BASE_REF=$base_ref" >> $GITHUB_OUTPUT
          echo "PR_TITLE=$pr_title" >> $GITHUB_OUTPUT

      - name: Set configuration variables
        id: set_config
        env:
          UPDATETESTBRANCH_TEST_BRANCH: ${{ vars.UPDATETESTBRANCH_TEST_BRANCH || env.TEST_BRANCH }}
          UPDATETESTBRANCH_FEATURE_TEST_PREFIX: ${{ vars.UPDATETESTBRANCH_FEATURE_TEST_PREFIX || env.FEATURE_TEST_PREFIX }}
          UPDATETESTBRANCH_BOT_LABEL: ${{ vars.UPDATETESTBRANCH_BOT_LABEL || env.BOT_LABEL }}
          UPDATETESTBRANCH_DISABLE_COMMENTS: ${{ vars.UPDATETESTBRANCH_DISABLE_COMMENTS || env.DISABLE_COMMENTS }}
          UPDATETESTBRANCH_AUTOMERGE: ${{ vars.UPDATETESTBRANCH_AUTOMERGE || env.AUTOMERGE }}
        run: |
          # Sanitize inputs to prevent code injection
          printf 'TEST_BRANCH=%s\n' "$UPDATETESTBRANCH_TEST_BRANCH" >> $GITHUB_OUTPUT
          printf 'FEATURE_TEST_PREFIX=%s\n' "$UPDATETESTBRANCH_FEATURE_TEST_PREFIX" >> $GITHUB_OUTPUT
          printf 'BOT_LABEL=%s\n' "$UPDATETESTBRANCH_BOT_LABEL" >> $GITHUB_OUTPUT
          printf 'DISABLE_COMMENTS=%s\n' "$UPDATETESTBRANCH_DISABLE_COMMENTS" >> $GITHUB_OUTPUT
          printf 'AUTOMERGE=%s\n' "$UPDATETESTBRANCH_AUTOMERGE" >> $GITHUB_OUTPUT

      - name: Look for existing update PR
        id: check_pr
        env:
          TEST_BRANCH: ${{ steps.set_config.outputs.TEST_BRANCH }}
          FEATURE_BRANCH: ${{ steps.get_pr_info.outputs.HEAD_REF }}
          FEATURE_TEST_PREFIX: ${{ steps.set_config.outputs.FEATURE_TEST_PREFIX }}
        run: |
          feature_test_branch="${FEATURE_TEST_PREFIX}${FEATURE_BRANCH}"

          if [ $(gh pr list --base "${TEST_BRANCH}" --head "${feature_test_branch}" --state open | wc -l) -gt 0 ]; then
            echo "PR already exists."
            echo "PR_EXISTS=true" >> $GITHUB_OUTPUT
          else
            echo "No PR of ${feature_test_branch} to ${TEST_BRANCH} found."
            echo "PR_EXISTS=false" >> $GITHUB_OUTPUT
          fi

      - name: Ensure bot label exists
        env:
          GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          BOT_LABEL: ${{ steps.set_config.outputs.bot_label }}
        run: |
          if [ -z "$(gh label list --json "id,name" --jq '.[] | select(.name == "'"${BOT_LABEL}"'")')" ]; then
            if ! gh label create "${BOT_LABEL}" --color CCCCCC --description "Automated pull requests"; then
              echo "::error::Failed to create label ${BOT_LABEL}. No label will be applied to the test PR. You can create it manually by going to the Labels section of the repository settings."
              BOT_LABEL=""
            else
              echo "::notice::Label '${BOT_LABEL}' created"
            fi
          else
            echo "Label ${BOT_LABEL} already exists"
          fi

      - name: Set up Git
        env:
          TOKEN_JWT: ${{ steps.get_app_jwt.outputs.TOKEN_JWT }}
        run: |
          if [ -n "$TOKEN_JWT" ]; then
            echo "Using GitHub App JWT for Git identity"
            .github/scripts/setup-git-identity.sh "$TOKEN_JWT"
          else
            echo "Using GitHub Actions bot for Git identity"
            git config --global user.name "github-actions[bot]"
            git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          fi

      - name: Set environment variables for cherry-pick
        if: ${{ env.SKIP_ALL == 'false' }}
        env:
          TEST_BRANCH: ${{ steps.set_config.outputs.TEST_BRANCH }}
          FEATURE_TEST_PREFIX: ${{ steps.set_config.outputs.FEATURE_TEST_PREFIX }}
          FEATURE_BRANCH: ${{ steps.get_pr_info.outputs.HEAD_REF }}
          BASE_BRANCH: ${{ steps.get_pr_info.outputs.BASE_REF }}
        run: |
          # Sanitize inputs to prevent code injection
          printf 'FEATURE_TEST_BRANCH=%s%s\n' "${FEATURE_TEST_PREFIX}" "${FEATURE_BRANCH}" >> $GITHUB_ENV
          printf 'HEAD_REF=%s\n' "${FEATURE_BRANCH}" >> $GITHUB_ENV
          printf 'BASE_REF=%s\n' "${BASE_BRANCH}" >> $GITHUB_ENV

          # Set git settings
          git config set advice.mergeConflict false

      - name: Check branch settings
        if: ${{ env.SKIP_ALL == 'false' }}
        env:
          FEATURE_BRANCH: ${{ steps.get_pr_info.outputs.HEAD_REF }}
          TEST_BRANCH: ${{ steps.set_config.outputs.TEST_BRANCH }}
          BASE_BRANCH: ${{ steps.get_pr_info.outputs.BASE_REF }}
        run: |
          if [ "${FEATURE_BRANCH}" == "${TEST_BRANCH}" ]; then
            echo "::error::You cannot update the test branch ${TEST_BRANCH} with itself."
            echo "SKIP_ALL=true" >> $GITHUB_ENV
            exit 1
          fi
          if [ "${BASE_BRANCH}" == "${TEST_BRANCH}" ]; then
            echo "::error::The base branch cannot be the same as the test branch ${TEST_BRANCH}."
            echo "SKIP_ALL=true" >> $GITHUB_ENV
            exit 1
          fi

      - name: Check if test branch exists
        if: ${{ env.SKIP_ALL == 'false' }}
        env:
          TEST_BRANCH: ${{ steps.set_config.outputs.TEST_BRANCH }}
        run: |
          if ! git ls-remote --heads origin | grep -q "refs/heads/${TEST_BRANCH}$"; then
            echo "::error::Branch ${TEST_BRANCH} does not exist. Please create the branch first."
            echo "SKIP_ALL=true" >> $GITHUB_ENV
            exit 1
          fi

      - name: Get list of feature commits
        id: get_feature_commits
        if: ${{ env.SKIP_ALL == 'false' }}
        env:
          BASE_BRANCH: ${{ steps.get_pr_info.outputs.BASE_REF }}
          FEATURE_BRANCH: ${{ steps.get_pr_info.outputs.HEAD_REF }}
        run: |
          git fetch origin "${BASE_BRANCH}"
          git fetch origin "${FEATURE_BRANCH}"

          feature_commits=$(git log --reverse --no-merges --pretty=format:%h "origin/${BASE_BRANCH}..origin/${FEATURE_BRANCH}")

          if [ -z "$feature_commits" ]; then
            echo "SKIP_ALL=true" >> $GITHUB_ENV
            echo "NO_CHANGES=true" >> $GITHUB_ENV
            echo "::notice::No new commits found. Skipping update."
            exit 0
          fi

          feature_commits_pretty=$(git log --reverse --no-merges --pretty=format:"- %s (%h)" "origin/${BASE_BRANCH}..origin/${FEATURE_BRANCH}")

          echo -e 'Feature commits:\n'"$feature_commits_pretty"
          for commit in $feature_commits; do
            echo "::debug::$commit"
          done

          {
            echo "FEATURE_COMMITS<<EOF"
            echo "$feature_commits"
            echo "EOF"
          } >> $GITHUB_ENV

      - name: Checkout feature test branch
        id: check_feat_test
        if: ${{ env.SKIP_ALL == 'false' }}
        env:
          TEST_BRANCH: ${{ steps.set_config.outputs.TEST_BRANCH }}
        run: |
          feature_test_branch='${{ env.FEATURE_TEST_BRANCH }}'
          if git ls-remote --heads origin | grep -q "refs/heads/$feature_test_branch$"; then
            echo "Branch $feature_test_branch found."
            git fetch origin "$feature_test_branch"
            git checkout "$feature_test_branch"
          else
            echo "No branch $feature_test_branch found."
            git checkout -b "$feature_test_branch" "origin/${TEST_BRANCH}"
          fi

      - name: Get list of already cherry-picked commits
        id: get_cherry_picked_commits
        if: ${{ env.SKIP_ALL == 'false' }}
        env:
          TEST_BRANCH: ${{ steps.set_config.outputs.TEST_BRANCH }}
          FEATURE_BRANCH: ${{ steps.get_pr_info.outputs.HEAD_REF }}
        run: |
          git fetch origin "${TEST_BRANCH}"
          git fetch origin "${FEATURE_BRANCH}"

          # Get the timestamp of the earliest commit in the feature branch to use as cutoff point.
          # Since we're dealing with two separate histories (test branch and feature branch),
          # we use commit timestamps to determine which commits in the test feature branch
          # could potentially contain cherry-picks from the feature branch.
          earliest_feature_timestamp=$(git log --reverse --pretty=format:"%ct" "origin/${BASE_REF}..origin/${FEATURE_BRANCH}" | head -1)

          commit_separator=$'\001'

          if [ -n "$earliest_feature_timestamp" ]; then
            echo "::debug::Earliest feature branch commit timestamp: $earliest_feature_timestamp ($(date -d @$earliest_feature_timestamp))"
            # Compare test feature branch with base branch (not test branch) to see all cherry-picked commits
            # (both merged and unmerged). Filter by timestamp to only examine commits made after
            # the earliest feature branch commit, since cherry-picks must occur after the original commits.
            feature_test_bodies=$(git log --reverse --pretty=format:"%B$commit_separator" --since="@$earliest_feature_timestamp" "origin/${BASE_REF}..${FEATURE_TEST_BRANCH}")
          else
            echo "::debug::No feature branch commits found, examining all test feature branch commits"
            # Fallback: compare test feature branch with base branch to see all cherry-picked commits
            feature_test_bodies=$(git log --reverse --pretty=format:"%B$commit_separator" "origin/${BASE_REF}..${FEATURE_TEST_BRANCH}")
          fi

          if [ -z "$feature_test_bodies" ]; then
            echo "No new commits in \"$FEATURE_TEST_BRANCH\" found."
            echo "PICKED_COMMITS=" >> $GITHUB_ENV
            exit 0
          fi

          feature_test_bodies=${feature_test_bodies%$commit_separator}

          picked_commits=()
          IFS=$commit_separator
          for msg in $feature_test_bodies; do
            echo "::debug::Full message:"
            while IFS= read -r line; do
              echo "::debug::  $line"
            done <<< "$msg"
            # Find all cherry-pick notices in the message (handles squash commits with multiple cherry-picks)
            commits=$(echo -n "$msg" | grep -oP '(?<=\(cherry picked from commit )\S*(?=\))' || true)
            if [[ -z "$commits" ]]; then
              continue
            fi
            # Process each cherry-picked commit found
            while IFS= read -r commit; do
              if [[ $(git rev-parse --verify "$commit" 2>/dev/null) ]]; then
                commit=${commit:0:8}
                picked_commits+=("$commit")
                echo "::debug::Commit $commit found."
              else
                echo "::debug::Commit $commit not found in the repository."
              fi
            done <<< "$commits"
          done
          unset IFS

          if [ ${#picked_commits[@]} -eq 0 ]; then
            echo "No previously cherry-picked commits found."
            echo "PICKED_COMMITS=" >> $GITHUB_ENV
            exit 0
          fi

          echo "Cherry-picked commits:"
          for commit in "${picked_commits[@]}"; do
            if git log --pretty=format:"- %s (%h)" -n 1 $commit 1>/dev/null 2>&1; then
              echo "$(git log --pretty=format:"- %s (%h)" -n 1 $commit)"
            else
              echo "- Unknown commit ($commit)"
            fi
          done

          {
            echo "PICKED_COMMITS<<EOF"
            for commit in "${picked_commits[@]}"; do
              printf "%s\n" "$commit"
            done
            echo "EOF"
          } >> $GITHUB_ENV

      - name: Determine commits to cherry-pick
        if: ${{ env.SKIP_ALL == 'false' }}
        run: |
          feature_commits=(${{ env.FEATURE_COMMITS }})
          picked_commits=(${{ env.PICKED_COMMITS }})

          echo -e 'Feature commits: '"${feature_commits[*]}"
          echo -e 'Picked commits: '"${picked_commits[*]:-None}"

          new_commits=()
          if [ -z "$picked_commits" ]; then
            new_commits=("${feature_commits[@]}")
          else
            for feature_commit in "${feature_commits[@]}"; do
              found=0
              for picked in "${picked_commits[@]}"; do
                if [[ "$picked" == "$feature_commit"* ]]; then
                  found=1
                  break
                fi
              done
              if [ $found -eq 0 ]; then
                new_commits+=("$feature_commit")
              fi
            done
          fi

          echo "## Commits to cherry-pick:" >> $GITHUB_STEP_SUMMARY

          if [ ${#new_commits[@]} -eq 0 ]; then
            echo "SKIP_ALL=true" >> $GITHUB_ENV
            echo "NO_CHANGES=true" >> $GITHUB_ENV
            echo "No new commits to cherry-pick found. Skipping update." >> $GITHUB_STEP_SUMMARY
          else
            for commit in "${new_commits[@]}"; do
              echo "$(git log --pretty=format:"- %s (%h)" -n 1 $commit)" >> $GITHUB_STEP_SUMMARY
            done
          fi

          {
            echo "FEATURE_COMMITS<<EOF"
            for commit in "${new_commits[@]}"; do
              printf "%s\n" "$commit"
            done
            echo "EOF"
          } >> $GITHUB_ENV

      - name: Cherry-pick new commits
        id: cherry_pick
        if: ${{ env.SKIP_ALL == 'false' }}
        run: |
          feature_commits=(${{ env.FEATURE_COMMITS }})
          echo "## Cherry-pick Process"
          echo "Cherry-picking the following commits:"
          echo "${feature_commits[*]}"
          successful_commits=()
          success=true
          no_changes=true

          set +e
          for commit in "${feature_commits[@]}"; do
            git cherry-pick --empty=keep -x $commit 1>/dev/null
            if [ $? -ne 0 ]; then
              echo "::error::Cherry-pick failed for commit $commit."
              success=false
              break
            fi
            if [ -n "$(git status --porcelain | grep '^U')" ]; then
              echo "::error::Unmerged files detected after cherry-pick of $commit."
              success=false
              break
            fi
            successful_commits+=($commit)
            commit_id=$(git rev-parse HEAD)
            if ! git diff --quiet $commit_id^ $commit_id
            then
              no_changes=false
            fi
          done
          set -e

          echo "NO_CHANGES=$no_changes" >> $GITHUB_ENV
          if [ "$success" = "false" ]; then
            echo "CHERRY_PICK_FAILED=true" >> $GITHUB_ENV
          else
            echo "CHERRY_PICK_FAILED=false" >> $GITHUB_ENV
          fi
          {
            echo "PICKED_COMMITS<<EOF"
            for commit in "${successful_commits[@]}"; do
              printf "%s\n" "$commit"
            done
            echo "EOF"
          } >> $GITHUB_ENV

          if [ "$success" = "false" ]; then
            echo "Cherry-pick failed."
          else
            echo "Cherry-pick successful."
          fi

      - name: "On success: Commit & push cherry-picked changes"
        if: ${{ env.SKIP_ALL == 'false' && env.CHERRY_PICK_FAILED == 'false' }}
        env:
          TEST_BRANCH: ${{ steps.set_config.outputs.TEST_BRANCH }}
        run: |
          echo "**Final result: ‚úÖ Success**" >> $GITHUB_STEP_SUMMARY
          push=false
          if [ -n "$(git status --porcelain)" ]; then
            git commit
          fi
          if git ls-remote --heads origin | grep -q "refs/heads/${FEATURE_TEST_BRANCH}$"; then
            if [ -n "$(git log "origin/${FEATURE_TEST_BRANCH}..${FEATURE_TEST_BRANCH}")" ]; then
              push=true
            fi
          else
            if [ ${{ env.NO_CHANGES }} == 'false' ]; then
              push=true
            fi
          fi
          if [ $push == true ]; then
            git push origin "${FEATURE_TEST_BRANCH}"
          else
            echo "No changes to push."
          fi

      - name: "On failure: Determine missing commits"
        if: ${{ env.SKIP_ALL == 'false' && env.CHERRY_PICK_FAILED == 'true' }}
        run: |
          echo "**Final result: ‚ùå Failure**" >> $GITHUB_STEP_SUMMARY

          feature_commits=(${{ env.FEATURE_COMMITS }})
          picked_commits=(${{ env.PICKED_COMMITS }})

          echo -e 'Feature commits: '"${feature_commits[*]}"
          if [ -n "$picked_commits" ]; then
            echo -e 'Picked commits: '"${picked_commits[*]}"
          fi

          missing_commits=()
          for commit in "${feature_commits[@]}"; do
            if [[ ! " ${picked_commits[@]} " =~ " $commit " ]] ; then
              missing_commits+=($commit)
            fi
          done

          echo '### Missing commits' >> $GITHUB_STEP_SUMMARY
          while IFS= read -r commit; do
            echo "$(git log --pretty=format:"- %s (%h)" -n 1 $commit)" >> $GITHUB_STEP_SUMMARY
          done <<< "${missing_commits[*]}"

          {
            echo "MISSING_COMMITS<<EOF"
            echo "${missing_commits[*]}"
            echo "EOF"
          } >> $GITHUB_ENV

      - name: "On failure: Abort cherry-pick & push changes"
        if: ${{ env.SKIP_ALL == 'false' && env.CHERRY_PICK_FAILED == 'true' }}
        env:
          FEATURE_BRANCH: ${{ steps.get_pr_info.outputs.HEAD_REF }}
        run: |
          git reset --hard
          if [ -z "$(git log "origin/${FEATURE_TEST_BRANCH}..${FEATURE_TEST_BRANCH}")" ]; then
            echo "Pushing empty commit to ${FEATURE_TEST_BRANCH} to create PR."
            git commit --allow-empty -m "Cherry-pick of ${FEATURE_BRANCH} failed.

          Manual resolution required."
          fi
          git push origin "${FEATURE_TEST_BRANCH}"
          echo "NO_CHANGES=false" >> $GITHUB_ENV

      - name: Update progress comment with core workflow outcome
        uses: peter-evans/create-or-update-comment@v4
        if: always()
        with:
          comment-id: ${{ steps.create_progress_comment.outputs.comment-id }}
          edit-mode: replace
          body: |
            ${{ env.CHERRY_PICK_FAILED == 'false' && env.NO_CHANGES == 'true' && '‚úÖ No new changes found to cherry-pick. Finishing workflow...' || (env.CHERRY_PICK_FAILED == 'false' && '‚úÖ Cherry-pick completed successfully! Finishing workflow...' || '‚ùå Cherry-pick failed due to conflicts. Finishing workflow...') }}

            [View workflow run](${{ env.RUN_URL }})

      - name: Check if feature test branch exists
        id: check_branch
        run: |
          if git ls-remote --heads origin | grep -q "refs/heads/${FEATURE_TEST_BRANCH}$"; then
            echo "BRANCH_EXISTS=true" >> $GITHUB_OUTPUT
            echo "Feature test branch ${FEATURE_TEST_BRANCH} exists remotely."
          else
            echo "BRANCH_EXISTS=false" >> $GITHUB_OUTPUT
            echo "Feature test branch ${FEATURE_TEST_BRANCH} does not exist remotely."
          fi

      - name: Get feature PR URL
        id: get_feature_pr_url
        env:
          FALLBACK_URL: ${{ github.server_url }}/${{ github.repository }}/pull/${{ github.event.issue.number }}
        run: |
          pr_info=$(gh pr view ${{ github.event.issue.number }} --json url)

          printf "::debug::PR info: %q\n" "$pr_info"

          if [ -z "$pr_info" ]; then
            echo "::notice::Failed to get PR information. Using fallback URL."
            pr_url="$FALLBACK_URL"
          else
            pr_url=$(echo "$pr_info" | jq -r '.url')
          fi

          echo "PR URL: $pr_url"
          echo "FEATURE_PR_URL=$pr_url" >> $GITHUB_OUTPUT

      - name: Create/Update test pull request
        id: create_pr
        if: steps.check_pr.outputs.pr_exists == 'true' || env.NO_CHANGES == 'false' || (steps.check_pr.outputs.pr_exists == 'false' && steps.check_branch.outputs.branch_exists == 'true')
        env:
          FEATURE_BRANCH: ${{ steps.get_pr_info.outputs.HEAD_REF }}
          BASE_BRANCH: ${{ steps.get_pr_info.outputs.BASE_REF }}
          TEST_BRANCH: ${{ steps.set_config.outputs.TEST_BRANCH }}
          BOT_LABEL: ${{ steps.set_config.outputs.BOT_LABEL }}
          PR_EXISTS: ${{ steps.check_pr.outputs.PR_EXISTS }}
          FEATURE_TITLE: ${{ github.event.issue.title }}
          FEATURE_PR_URL: ${{ steps.get_feature_pr_url.outputs.FEATURE_PR_URL }}
          ASSIGNEES_JSON: ${{ toJSON(github.event.issue.assignees) }}
        run: |
          feature_test_title="${FEATURE_TITLE} - Test"
          echo "PR title: ${feature_test_title}"
          body="This automated pull request adds the cherry-picked changes from \`${FEATURE_BRANCH}\` to \`${TEST_BRANCH}\`.
          See ${FEATURE_PR_URL} for more details."

          # Extract assignee logins from JSON array and format as comma-separated list
          ASSIGNEES=$(echo "${ASSIGNEES_JSON}" | jq -r 'if . == null or . == [] then "" else map(.login) | join(",") end')

          if [ "${PR_EXISTS}" == 'false' ]; then
            # Build assignee parameter if there are assignees
            ASSIGNEE_PARAM=""
            if [ -n "${ASSIGNEES}" ]; then
              ASSIGNEE_PARAM="--assignee ${ASSIGNEES}"
            fi

            TEST_PR_URL=$(gh pr create \
              --base "${TEST_BRANCH}" \
              --head "${FEATURE_TEST_BRANCH}" \
              --title "${feature_test_title}" \
              --label "${BOT_LABEL}" \
              --draft \
              ${ASSIGNEE_PARAM} \
              --body "${body}")
            echo "::notice::${TEST_PR_URL} created."
          else
            # Build assignee parameter if there are assignees
            ASSIGNEE_PARAM=""
            if [ -n "${ASSIGNEES}" ]; then
              ASSIGNEE_PARAM="--add-assignee ${ASSIGNEES}"
            fi

            TEST_PR_URL=$(gh pr edit "${FEATURE_TEST_BRANCH}" \
              --title "${feature_test_title}" \
              --body "${body}" \
              ${ASSIGNEE_PARAM})
            echo "::notice::${TEST_PR_URL} updated."
          fi

          pr_number=$(basename "${TEST_PR_URL}")

          echo "TEST_PR_EXISTS=true" >> $GITHUB_OUTPUT
          echo "TEST_PR_URL=${TEST_PR_URL}" >> $GITHUB_OUTPUT
          echo "TEST_PR_NUMBER=${pr_number}" >> $GITHUB_OUTPUT

      - name: Set pull request status
        if: steps.create_pr.outputs.test_pr_exists == 'true'
        env:
          TEST_PR_NUMBER: ${{ steps.create_pr.outputs.test_pr_number }}
        run: |
          if [ "${CHERRY_PICK_FAILED}" == "false" ]; then
            gh pr ready "${FEATURE_TEST_BRANCH}"
          else
            gh pr ready --undo "${FEATURE_TEST_BRANCH}"
          fi

      - name: Enable auto-merge on test PR
        if: steps.create_pr.outputs.test_pr_exists == 'true' && env.CHERRY_PICK_FAILED == 'false' && steps.set_config.outputs.AUTOMERGE == 'true'
        env:
          TEST_PR_NUMBER: ${{ steps.create_pr.outputs.test_pr_number }}
        run: |
          # Enable auto-merge using gh CLI (requires repo admin permissions)
          gh pr merge "$TEST_PR_NUMBER" --auto --squash || echo "::notice::Auto-merge could not be enabled."

      - name: Clean up old comments
        uses: actions/github-script@v7
        continue-on-error: true
        env:
          TEST_PR_URL: ${{ steps.create_pr.outputs.test_pr_url }}
          NOTICE_COMMENT_TAG: ${{ env.NOTICE_COMMENT_TAG }}
        with:
          script: |
            (async () => {
              const TEST_PR_URL = process.env.TEST_PR_URL;
              const NOTICE_COMMENT_TAG = process.env.NOTICE_COMMENT_TAG;

              let newPrComments = [];
              if (TEST_PR_URL) {
                const urlSubstrings = TEST_PR_URL.split('/');
                const newPrNumber = urlSubstrings[urlSubstrings.length - 1];
                try {
                  newPrComments = await github.rest.issues.listComments({
                    issue_number: newPrNumber,
                    owner: context.repo.owner,
                    repo: context.repo.repo
                  });
                } catch (error) {
                  process.stdout.write(`::error::Error retrieving comments from new PR #${newPrNumber}: ${error.message}\n`);
                  newPrComments = [];
                }
              }
              let oldPrComments = [];
              try {
                oldPrComments = await github.rest.issues.listComments({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo
                });
              } catch (error) {
                process.stdout.write(`::error::Error retrieving comments from PR #${context.issue.number}: ${error.message}\n`);
                oldPrComments = [];
              }
              const allComments = [oldPrComments, newPrComments];
              for (const comments of allComments) {
                if (comments && Array.isArray(comments.data)) {
                  for (const comment of comments.data) {
                    if (comment.user.login === 'github-actions[bot]' && comment.body.startsWith(NOTICE_COMMENT_TAG)) {
                      try {
                        await github.rest.issues.deleteComment({
                          comment_id: comment.id,
                          owner: context.repo.owner,
                          repo: context.repo.repo
                        });
                        process.stdout.write(`Deleted comment ${comment.html_url}\n`);
                      } catch (error) {
                        process.stdout.write(`::notice::Error deleting comment ${comment.html_url}: ${error.message}\n`);
                      }
                    }
                  }
                } else {
                  process.stdout.write(`::debug::Comment data is not iterable.`)
                }
              }
            })();

      - name: Comment on test PR (on failure)
        if: env.CHERRY_PICK_FAILED == 'true' && steps.set_config.outputs.DISABLE_COMMENTS == 'false'
        uses: peter-evans/create-or-update-comment@v4
        env:
          TEST_BRANCH: ${{ steps.set_config.outputs.TEST_BRANCH }}
        with:
          issue-number: ${{ steps.create_pr.outputs.test_pr_number }}
          body: |
            ${{ env.NOTICE_COMMENT_TAG }}
            **Automatic ${{ env.TEST_BRANCH }} update failed.**

            To manually resolve the merge conflicts, please follow these steps:

            1) Checkout the latest version of the branch `${{ env.FEATURE_TEST_BRANCH }}` with the following commands:
            ```bash
            git fetch origin ${{ env.FEATURE_TEST_BRANCH }}
            git checkout ${{ env.FEATURE_TEST_BRANCH }}
            git reset --hard origin/${{ env.FEATURE_TEST_BRANCH }}
            git cherry-pick -x ${{ env.MISSING_COMMITS }}
            ```
            2) Manually cherry-pick the failing commits and resolve any conflicts.
            3) Push the changes and set the PR to ready for review.

      - name: Update progress comment with final result
        if: steps.set_config.outputs.DISABLE_COMMENTS == 'false'
        uses: peter-evans/create-or-update-comment@v4
        env:
          FEATURE_BRANCH: ${{ steps.get_pr_info.outputs.HEAD_REF }}
          TEST_BRANCH: ${{ steps.set_config.outputs.TEST_BRANCH }}
          TEST_PR_URL: ${{ steps.create_pr.outputs.test_pr_url }}
          TEST_PR_EXISTS: ${{ steps.create_pr.outputs.test_pr_exists }}
        with:
          comment-id: ${{ steps.create_progress_comment.outputs.comment-id }}
          edit-mode: replace
          body: |
            ${{ env.NO_CHANGES == 'true' && env.TEST_PR_EXISTS == 'true' && format('‚úÖ No new changes found to cherry-pick.

            No new changes were found in `{0}` to update the `{1}` branch.

            A pull request has been created or updated for the existing test branch. See {2} for more details.

            [View workflow run]({3})', env.FEATURE_BRANCH, env.TEST_BRANCH, env.TEST_PR_URL, env.RUN_URL) || env.NO_CHANGES == 'true' && format('‚úÖ No new changes found to cherry-pick.

            No new changes were found in `{0}` to update the `{1}` branch.

            [View workflow run]({2})', env.FEATURE_BRANCH, env.TEST_BRANCH, env.RUN_URL) || env.CHERRY_PICK_FAILED == 'false' && format('‚úÖ Cherry-pick completed successfully!

            The cherry-picked changes from `{0}` are ready to be added to the `{1}` branch.

            A new pull request has been created to test the changes. See {2} for more details.

            [View workflow run]({3})', env.FEATURE_BRANCH, env.TEST_BRANCH, env.TEST_PR_URL, env.RUN_URL) || format('‚ùå Cherry-pick failed due to conflicts.

            Unable to cherry-pick the changes from `{0}` to the `{1}` branch.

            A new pull request has been created to manually resolve the merge conflicts and test the changes. See {2} for more details.

            [View workflow run]({3})', env.FEATURE_BRANCH, env.TEST_BRANCH, env.TEST_PR_URL, env.RUN_URL) }}


  comment_error:
    name: Update Progress Comment on Error
    needs: [update_test_branch]
    runs-on: ubuntu-latest
    if: failure() && needs.update_test_branch.outputs.disable_comments == 'false'
    env:
      GH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Add comment with error
        uses: peter-evans/create-or-update-comment@v4
        if: needs.update_test_branch.outputs.progress_comment_id == ''
        env:
          RUN_URL: ${{ needs.update_test_branch.outputs.RUN_URL }}
        with:
          body: |
            ‚ùå An error occurred while updating the test branch.

            Please check the workflow run for details:
            [View workflow run](${{ env.RUN_URL }})

      - name: Update progress comment with error
        uses: peter-evans/create-or-update-comment@v4
        if: needs.update_test_branch.outputs.progress_comment_id != ''
        env:
          RUN_URL: ${{ needs.update_test_branch.outputs.RUN_URL }}
        with:
          comment-id: ${{ needs.update_test_branch.outputs.progress_comment_id }}
          edit-mode: replace
          body: |
            ‚ùå An error occurred while updating the test branch.

            Please check the workflow run for details:
            [View workflow run](${{ env.RUN_URL }})

