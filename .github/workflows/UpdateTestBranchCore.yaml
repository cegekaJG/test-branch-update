name: Update Test Branch Core

on:
  workflow_call:
    inputs:
      test_branch:
        description: 'The test branch to cherry-pick commits into (e.g., test/main)'
        required: true
        type: string
      feature_branch:
        description: 'The feature branch containing commits to cherry-pick'
        required: true
        type: string
      base_branch:
        description: 'The base branch for comparison'
        required: true
        type: string
      feature_test_prefix:
        description: 'Prefix for feature test branches (e.g., test/)'
        required: false
        type: string
        default: 'test/'
    outputs:
      cherry_pick_success:
        description: 'Whether cherry-pick was successful'
        value: ${{ jobs.update_test_branch.outputs.cherry_pick_success }}
      feature_test_branch:
        description: 'Name of the feature test branch'
        value: ${{ jobs.update_test_branch.outputs.feature_test_branch }}
      picked_commits:
        description: 'List of successfully picked commits'
        value: ${{ jobs.update_test_branch.outputs.picked_commits }}
      missing_commits:
        description: 'List of commits that failed to be picked'
        value: ${{ jobs.update_test_branch.outputs.missing_commits }}
      no_changes:
        description: 'Whether there were no changes to commit'
        value: ${{ jobs.update_test_branch.outputs.no_changes }}
      skip_all:
        description: 'Whether the workflow was skipped due to errors or no commits'
        value: ${{ jobs.update_test_branch.outputs.skip_all }}

  workflow_dispatch:
    inputs:
      test_branch:
        description: 'The test branch to cherry-pick commits into (e.g., test/main)'
        required: true
        type: string
      feature_branch:
        description: 'The feature branch containing commits to cherry-pick'
        required: true
        type: string
      base_branch:
        description: 'The base branch for comparison'
        required: true
        type: string
      feature_test_prefix:
        description: 'Prefix for feature test branches (e.g., test/)'
        required: false
        type: string
        default: 'test/'
permissions:
  contents: write

env:
  SKIP_ALL: false
  FEATURE_COMMITS: ''
  FEATURE_TEST_BRANCH: ''
  PICKED_COMMITS: ''
  ADDED_COMMITS: ''
  NO_CHANGES: true
  MISSING_COMMITS: ''
  CHERRY_PICK_FAILED: false

jobs:
  update_test_branch:
    name: Update Test Branch
    runs-on: ubuntu-latest
    outputs:
      cherry_pick_success: ${{ env.CHERRY_PICK_FAILED == 'false' }}
      feature_test_branch: ${{ env.FEATURE_TEST_BRANCH }}
      picked_commits: ${{ env.PICKED_COMMITS }}
      missing_commits: ${{ env.MISSING_COMMITS }}
      no_changes: ${{ env.NO_CHANGES }}
      skip_all: ${{ env.SKIP_ALL }}
    steps:
      - name: Checkout repository
        if: ${{ env.SKIP_ALL == 'false' }}
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 'Setup jq'
        if: ${{ env.SKIP_ALL == 'false' }}
        uses: dcarbone/install-jq-action@v3

      - name: 'Set file permissions'
        run: |
          chmod +x .github/scripts/get-jwt.sh
          chmod +x .github/scripts/setup-git-identity.sh

      - name: 'Check for GitHub App JWT'
        id: get_app_jwt
        env:
          CUSTOM_TOKEN: ${{ secrets.UPDATETESTTOKEN }}
        run: |
          if [ -z "$CUSTOM_TOKEN" ]; then
            cat << 'EOF' >> $GITHUB_STEP_SUMMARY
          ## ⚠️ UPDATETESTTOKEN Secret Not Found

          The UPDATETESTTOKEN secret is required to automatically trigger pull request workflows.
          For information on how to add the repository secret, see: https://github.com/microsoft/AL-Go/blob/main/Scenarios/GhTokenWorkflow.md
          EOF
          else
            TOKEN_JWT_VALUE=$(.github/scripts/get-jwt.sh "$CUSTOM_TOKEN")
            echo "TOKEN_JWT=$TOKEN_JWT_VALUE" >> $GITHUB_OUTPUT
          fi

      - name: Set up Git
        env:
          TOKEN_JWT: ${{ steps.get_app_jwt.outputs.TOKEN_JWT }}
        run: |
          if [ -n "$TOKEN_JWT" ]; then
            echo "Using GitHub App JWT for Git identity"
            .github/scripts/setup-git-identity.sh "$TOKEN_JWT"
          else
            echo "Using GitHub Actions bot for Git identity"
            git config --global user.name "github-actions[bot]"
            git config --global user.email "41898282+github-actions[bot]@users.noreply.github.com"
          fi

      - name: 'Revert changes from setting permissions'
        run: |
          git checkout -- .github/scripts/

      - name: Set environment variables
        if: ${{ env.SKIP_ALL == 'false' }}
        env:
          TEST_BRANCH_INPUT: ${{ inputs.test_branch }}
          FEATURE_TEST_PREFIX_INPUT: ${{ inputs.feature_test_prefix }}
          FEATURE_BRANCH_INPUT: ${{ inputs.feature_branch }}
          BASE_BRANCH_INPUT: ${{ inputs.base_branch }}
        run: |
          # Sanitize inputs to prevent code injection
          printf 'TEST_BRANCH=%s\n' "${TEST_BRANCH_INPUT}" >> $GITHUB_ENV
          printf 'FEATURE_TEST_PREFIX=%s\n' "${FEATURE_TEST_PREFIX_INPUT}" >> $GITHUB_ENV
          printf 'FEATURE_TEST_BRANCH=%s%s\n' "${FEATURE_TEST_PREFIX_INPUT}" "${FEATURE_BRANCH_INPUT}" >> $GITHUB_ENV
          printf 'HEAD_REF=%s\n' "${FEATURE_BRANCH_INPUT}" >> $GITHUB_ENV
          printf 'BASE_REF=%s\n' "${BASE_BRANCH_INPUT}" >> $GITHUB_ENV

          # Set git settings
          git config set advice.mergeConflict false

      - name: Check branch settings
        if: ${{ env.SKIP_ALL == 'false' }}
        env:
          FEATURE_BRANCH_INPUT: ${{ inputs.feature_branch }}
          TEST_BRANCH_INPUT: ${{ inputs.test_branch }}
          BASE_BRANCH_INPUT: ${{ inputs.base_branch }}
        run: |
          if [ "${FEATURE_BRANCH_INPUT}" == "${TEST_BRANCH_INPUT}" ]; then
            echo "::error::You cannot update the test branch ${TEST_BRANCH_INPUT} with itself."
            echo "SKIP_ALL=true" >> $GITHUB_ENV
            exit 1
          fi
          if [ "${BASE_BRANCH_INPUT}" == "${TEST_BRANCH_INPUT}" ]; then
            echo "::error::The base branch cannot be the same as the test branch ${TEST_BRANCH_INPUT}."
            echo "SKIP_ALL=true" >> $GITHUB_ENV
            exit 1
          fi

      - name: Check if test branch exists
        if: ${{ env.SKIP_ALL == 'false' }}
        env:
          TEST_BRANCH_INPUT: ${{ inputs.test_branch }}
        run: |
          if ! git ls-remote --heads origin | grep -q "refs/heads/${TEST_BRANCH_INPUT}$"; then
            echo "::error::Branch ${TEST_BRANCH_INPUT} does not exist. Please create the branch first."
            echo "SKIP_ALL=true" >> $GITHUB_ENV
            exit 1
          fi

      - name: Get list of feature commits
        id: get_feature_commits
        if: ${{ env.SKIP_ALL == 'false' }}
        env:
          BASE_BRANCH_INPUT: ${{ inputs.base_branch }}
          FEATURE_BRANCH_INPUT: ${{ inputs.feature_branch }}
        run: |
          git fetch origin "${BASE_BRANCH_INPUT}"
          git fetch origin "${FEATURE_BRANCH_INPUT}"

          feature_commits=$(git log --reverse --no-merges --pretty=format:%h "origin/${BASE_BRANCH_INPUT}..origin/${FEATURE_BRANCH_INPUT}")

          if [ -z "$feature_commits" ]; then
            echo "SKIP_ALL=true" >> $GITHUB_ENV
            echo "NO_CHANGES=true" >> $GITHUB_ENV
            echo "::notice::No new commits found. Skipping update."
            exit 0
          fi

          feature_commits_pretty=$(git log --reverse --no-merges --pretty=format:"- %s (%h)" "origin/${BASE_BRANCH_INPUT}..origin/${FEATURE_BRANCH_INPUT}")

          echo -e 'Feature commits:\n'"$feature_commits_pretty"
          for commit in $feature_commits; do
            echo "::debug::$commit"
          done

          {
            echo "FEATURE_COMMITS<<EOF"
            echo "$feature_commits"
            echo "EOF"
          } >> $GITHUB_ENV

      - name: Checkout feature test branch
        id: check_feat_test
        if: ${{ env.SKIP_ALL == 'false' }}
        run: |
          feature_test_branch='${{ env.FEATURE_TEST_BRANCH }}'
          if git ls-remote --heads origin | grep -q "refs/heads/$feature_test_branch$"; then
            echo "Branch $feature_test_branch found."
            git fetch origin "$feature_test_branch"
            git checkout "$feature_test_branch"
          else
            echo "No branch $feature_test_branch found."
            git checkout -b "$feature_test_branch" "origin/${{ inputs.test_branch }}"
          fi

      - name: Get list of already cherry-picked commits
        id: get_cherry_picked_commits
        if: ${{ env.SKIP_ALL == 'false' }}
        env:
          TEST_BRANCH_INPUT: ${{ inputs.test_branch }}
          FEATURE_BRANCH_INPUT: ${{ inputs.feature_branch }}
        run: |
          git fetch origin "${TEST_BRANCH_INPUT}"
          git fetch origin "${FEATURE_BRANCH_INPUT}"

          # Get the timestamp of the earliest commit in the feature branch to use as cutoff point.
          # Since we're dealing with two separate histories (test branch and feature branch),
          # we use commit timestamps to determine which commits in the test feature branch
          # could potentially contain cherry-picks from the feature branch.
          earliest_feature_timestamp=$(git log --reverse --pretty=format:"%ct" "origin/${BASE_REF}..origin/${FEATURE_BRANCH_INPUT}" | head -1)

          commit_separator=$'\001'

          if [ -n "$earliest_feature_timestamp" ]; then
            echo "::debug::Earliest feature branch commit timestamp: $earliest_feature_timestamp ($(date -d @$earliest_feature_timestamp))"
            # Compare test feature branch with base branch (not test branch) to see all cherry-picked commits
            # (both merged and unmerged). Filter by timestamp to only examine commits made after
            # the earliest feature branch commit, since cherry-picks must occur after the original commits.
            feature_test_bodies=$(git log --reverse --pretty=format:"%B$commit_separator" --since="@$earliest_feature_timestamp" "origin/${BASE_REF}..${FEATURE_TEST_BRANCH}")
          else
            echo "::debug::No feature branch commits found, examining all test feature branch commits"
            # Fallback: compare test feature branch with base branch to see all cherry-picked commits
            feature_test_bodies=$(git log --reverse --pretty=format:"%B$commit_separator" "origin/${BASE_REF}..${FEATURE_TEST_BRANCH}")
          fi

          if [ -z "$feature_test_bodies" ]; then
            echo "No new commits in \"$FEATURE_TEST_BRANCH\" found."
            echo "PICKED_COMMITS=" >> $GITHUB_ENV
            exit 0
          fi

          feature_test_bodies=${feature_test_bodies%$commit_separator}

          picked_commits=()
          IFS=$commit_separator
          for msg in $feature_test_bodies; do
            echo "::debug::Full message:"
            while IFS= read -r line; do
              echo "::debug::  $line"
            done <<< "$msg"
            # Find all cherry-pick notices in the message (handles squash commits with multiple cherry-picks)
            commits=$(echo -n "$msg" | grep -oP '(?<=\(cherry picked from commit )\S*(?=\))' || true)
            if [[ -z "$commits" ]]; then
              continue
            fi
            # Process each cherry-picked commit found
            while IFS= read -r commit; do
              if [[ $(git rev-parse --verify "$commit" 2>/dev/null) ]]; then
                commit=${commit:0:8}
                picked_commits+=("$commit")
                echo "::debug::Commit $commit found."
              else
                echo "::debug::Commit $commit not found in the repository."
              fi
            done <<< "$commits"
          done
          unset IFS

          if [ ${#picked_commits[@]} -eq 0 ]; then
            echo "No previously cherry-picked commits found."
            echo "PICKED_COMMITS=" >> $GITHUB_ENV
            exit 0
          fi

          echo "Cherry-picked commits:"
          for commit in "${picked_commits[@]}"; do
            if git log --pretty=format:"- %s (%h)" -n 1 $commit 1>/dev/null 2>&1; then
              echo "$(git log --pretty=format:"- %s (%h)" -n 1 $commit)"
            else
              echo "- Unknown commit ($commit)"
            fi
          done

          {
            echo "PICKED_COMMITS<<EOF"
            for commit in "${picked_commits[@]}"; do
              printf "%s\n" "$commit"
            done
            echo "EOF"
          } >> $GITHUB_ENV

      - name: Determine commits to cherry-pick
        if: ${{ env.SKIP_ALL == 'false' }}
        run: |
          feature_commits=(${{ env.FEATURE_COMMITS }})
          picked_commits=(${{ env.PICKED_COMMITS }})

          echo -e 'Feature commits: '"${feature_commits[*]}"
          echo -e 'Picked commits: '"${picked_commits[*]:-None}"

          new_commits=()
          if [ -z "$picked_commits" ]; then
            new_commits=("${feature_commits[@]}")
          else
            for feature_commit in "${feature_commits[@]}"; do
              found=0
              for picked in "${picked_commits[@]}"; do
                if [[ "$picked" == "$feature_commit"* ]]; then
                  found=1
                  break
                fi
              done
              if [ $found -eq 0 ]; then
                new_commits+=("$feature_commit")
              fi
            done
          fi

          echo "## Commits to cherry-pick:" >> $GITHUB_STEP_SUMMARY

          if [ ${#new_commits[@]} -eq 0 ]; then
            echo "SKIP_ALL=true" >> $GITHUB_ENV
            echo "NO_CHANGES=true" >> $GITHUB_ENV
            echo "No new commits to cherry-pick found. Skipping update." >> $GITHUB_STEP_SUMMARY
          else
            for commit in "${new_commits[@]}"; do
              echo "$(git log --pretty=format:"- %s (%h)" -n 1 $commit)" >> $GITHUB_STEP_SUMMARY
            done
          fi

          {
            echo "FEATURE_COMMITS<<EOF"
            for commit in "${new_commits[@]}"; do
              printf "%s\n" "$commit"
            done
            echo "EOF"
          } >> $GITHUB_ENV

      - name: Cherry-pick new commits
        id: cherry_pick
        if: ${{ env.SKIP_ALL == 'false' }}
        run: |
          feature_commits=(${{ env.FEATURE_COMMITS }})
          echo "## Cherry-pick Process"
          echo "Cherry-picking the following commits:"
          echo "${feature_commits[*]}"
          successful_commits=()
          success=true
          no_changes=true

          set +e
          for commit in "${feature_commits[@]}"; do
            git cherry-pick --empty=keep -x $commit 1>/dev/null
            if [ $? -ne 0 ]; then
              echo "::error::Cherry-pick failed for commit $commit."
              success=false
              break
            fi
            if [ -n "$(git status --porcelain | grep '^U')" ]; then
              echo "::error::Unmerged files detected after cherry-pick of $commit."
              success=false
              break
            fi
            successful_commits+=($commit)
            commit_id=$(git rev-parse HEAD)
            if ! git diff --quiet $commit_id^ $commit_id
            then
              no_changes=false
            fi
          done
          set -e

          echo "NO_CHANGES=$no_changes" >> $GITHUB_ENV
          if [ "$success" = "false" ]; then
            echo "CHERRY_PICK_FAILED=true" >> $GITHUB_ENV
          else
            echo "CHERRY_PICK_FAILED=false" >> $GITHUB_ENV
          fi
          {
            echo "PICKED_COMMITS<<EOF"
            for commit in "${successful_commits[@]}"; do
              printf "%s\n" "$commit"
            done
            echo "EOF"
          } >> $GITHUB_ENV

          if [ "$success" = "false" ]; then
            echo "Cherry-pick failed."
          else
            echo "Cherry-pick successful."
          fi

      - name: "On success: Commit & push cherry-picked changes"
        if: ${{ env.SKIP_ALL == 'false' && env.CHERRY_PICK_FAILED == 'false' }}
        env:
          TEST_BRANCH_INPUT: ${{ inputs.test_branch }}
        run: |
          echo "**Final result: ✅ Success**" >> $GITHUB_STEP_SUMMARY
          push=false
          if [ -n "$(git status --porcelain)" ]; then
            git commit
          fi
          if git ls-remote --heads origin | grep -q "refs/heads/${FEATURE_TEST_BRANCH}$"; then
            if [ -n "$(git log "origin/${FEATURE_TEST_BRANCH}..${FEATURE_TEST_BRANCH}")" ]; then
              push=true
            fi
          else
            if [ ${{ env.NO_CHANGES }} == 'false' ]; then
              push=true
            fi
          fi
          if [ $push == true ]; then
            git push origin "${FEATURE_TEST_BRANCH}"
          else
            echo "No changes to push."
          fi

      - name: "On failure: Determine missing commits"
        if: ${{ env.SKIP_ALL == 'false' && env.CHERRY_PICK_FAILED == 'true' }}
        run: |
          echo "**Final result: ❌ Failure**" >> $GITHUB_STEP_SUMMARY

          feature_commits=(${{ env.FEATURE_COMMITS }})
          picked_commits=(${{ env.PICKED_COMMITS }})

          echo -e 'Feature commits: '"${feature_commits[*]}"
          if [ -n "$picked_commits" ]; then
            echo -e 'Picked commits: '"${picked_commits[*]}"
          fi

          missing_commits=()
          for commit in "${feature_commits[@]}"; do
            if [[ ! " ${picked_commits[@]} " =~ " $commit " ]] ; then
              missing_commits+=($commit)
            fi
          done

          echo '### Missing commits' >> $GITHUB_STEP_SUMMARY
          while IFS= read -r commit; do
            echo "$(git log --pretty=format:"- %s (%h)" -n 1 $commit)" >> $GITHUB_STEP_SUMMARY
          done <<< "${missing_commits[*]}"

          {
            echo "MISSING_COMMITS<<EOF"
            echo "${missing_commits[*]}"
            echo "EOF"
          } >> $GITHUB_ENV

      - name: "On failure: Abort cherry-pick & push changes"
        if: ${{ env.SKIP_ALL == 'false' && env.CHERRY_PICK_FAILED == 'true' }}
        env:
          FEATURE_BRANCH_INPUT: ${{ inputs.feature_branch }}
        run: |
          git reset --hard
          if [ -z "$(git log "origin/${FEATURE_TEST_BRANCH}..${FEATURE_TEST_BRANCH}")" ]; then
            echo "Pushing empty commit to ${FEATURE_TEST_BRANCH} to create PR."
            git commit --allow-empty -m "Cherry-pick of ${FEATURE_BRANCH_INPUT} failed.

          Manual resolution required."
          fi
          git push origin "${FEATURE_TEST_BRANCH}"
          echo "NO_CHANGES=false" >> $GITHUB_ENV
